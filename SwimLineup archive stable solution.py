# -*- coding: utf-8 -*-
"""Better Gandhi.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dPnXpve6b6aXPa04swiHN2E1sDy0Wy-D

# Welcome

Hi! If you want to use this project, follow these instructions.

1.   Scroll to the very bottom. All the way down!
2.   Click "Runtime" in the top menu.
3.   From the "Runtime" dropdown choose "Run All."

That's it!


---
.

.

.

.

.

.

.

.

# Object Oriented Section
This will include the classes:


*   Event
*   Swimtime
*   Swimmer
*   Timearchive
*   Entry3
*   Relay3
*   Lineup
"""

import math

class EVENT:
  distance = 50
  stroke = "Free"
  alt_names_dict = {"50 Free": ["50 FREE", "50 FREESTYLE", "50 Y FREE", "50 Y FREESTYLE", "50 YARD FREE", "50 YARD FREESTYLE", "50 FREE SCY", "50FR"],
                    "100 Free": ["100 FREE", "100 FREESTYLE", "100 Y FREE", "100 Y FREESTYLE", "100 YARD FREE", "100 YARD FREESTYLE", "100 FREE SCY", "100FR"],
                    "200 Free": ["200 FREE", "200 FREESTYLE", "200 Y FREE", "200 Y FREESTYLE", "200 YARD FREE", "200 YARD FREESTYLE", "200 FREE SCY", "200FR"],
                    "500 Free": ["500 FREE", "500 FREESTYLE", "500 Y FREE", "500 Y FREESTYLE", "500 YARD FREE", "500 YARD FREESTYLE", "500 FREE SCY", "500FR", "400500FR"],
                    "50 Back": ["50 BACK", "50 BACKSTROKE", "50 Y BACK", "50 Y BACKSTROKE", "50 YARD BACK", "50 YARD BACKSTROKE", "50 BACK SCY", "50BK"],
                    "100 Back": ["100 BACK", "100 BACKSTROKE", "100 Y BACK", "100 Y BACKSTROKE", "100 YARD BACK", "100 YARD BACKSTROKE", "100 BACK SCY", "100BK"],
                    "50 Breast": ["50 BREAST", "50 BREASTSTROKE", "50 Y BREAST", "50 Y BREASTSTROKE", "50 YARD BREAST", "50 YARD BREASTSTROKE", "50 BREAST SCY", "50BR"],
                    "100 Breast": ["100 BREAST", "100 BREASTSTROKE", "100 Y BREAST", "100 Y BREASTSTROKE", "100 YARD BREAST", "100 YARD BREASTSTROKE", "100 BREAST SCY", "100BR"],
                    "50 Fly": ["50 FLY", "50 BUTTERFLY", "50 Y FLY", "50 Y BUTTERFLY", "50 YARD FLY", "50 YARD BUTTERFLY", "50 FLY SCY", "50FL"],
                    "100 Fly": ["100 FLY", "100 BUTTERFLY", "100 Y FLY", "100 Y BUTTERFLY", "100 YARD FLY", "100 YARD BUTTERFLY", "100 FLY SCY", "100FL"],
                    "200 IM": ["200 IM", "200 INDIVIDUAL MEDLEY", "200 Y IM", "200 Y INDIVIDUAL MEDLEY", "200 YARD IM", "200 YARD INDIVIDUAL MEDLEY", "200 IM SCY", "200IM"],
                    "200 Free Relay": ["200 FREE RELAY", "200 FREESTYLE RELAY", "4X50 FREE", "4X50 FREESTYLE", "4X50 FREE RELAY", "4X50 FREESTYLE RELAY", "200 Y FREE RELAY", "200 Y FREESTYLE RELAY", "200 YARD FREE RELAY", "200 YARD FREESTYLE RELAY", "200 FREE RELAY SCY", "4X50FR", "200 F RELAY"],
                    "200 Medley Relay": ["200 MEDLEY RELAY", "200 Y MEDLEY RELAY", "200 YARD MEDLEY RELAY", "200 MEDLEY RELAY SCY", "200MR", "200 M RELAY"],
                    "400 Free Relay": ["400 FREE RELAY", "400 FREESTYLE RELAY", "4X100 FREE", "4X100 FREESTYLE", "4X100 FREE RELAY", "4X100 FREESTYLE RELAY", "400 Y FREE RELAY", "400 Y FREESTYLE RELAY", "400 YARD FREE RELAY", "400 YARD FREESTYLE RELAY", "400 FREE RELAY SCY", "4X100FR", "400 F RELAY"]}
  alt_names = alt_names_dict["50 Free"]

  def __init__(self, parameters):
    if type(parameters) is str:
      name = EVENT.get_primary_name(parameters)
      if name == "":
        name = "0 Non_Highschool_Event " + parameters.replace(" ","")
      words = name.split()
      self.distance = int(words[0])
      self.stroke = words[1]
      if len(words) > 2:
        self.stroke += " " + words[2]
      self.alt_names = EVENT.get_alt_names(parameters)
    elif type(parameters) is list and len(parameters) == 3:
      self.distance = parameters[0]
      self.stroke = parameters[1]
      self.alt_names = parameters[2]
    elif type(parameters) is list and len(parameters) == 2:
      self.distance = parameters[0]
      self.stroke = parameters[1]
      self.alt_names = EVENT.get_alt_names(str(self))

  def __hash__(self):
    return hash(repr(self))

  def get_primary_name(oneName):
    dictionary = EVENT.alt_names_dict
    if oneName in list(dictionary):
      return oneName
    for eventName in dictionary:
      if oneName.upper() in dictionary[eventName]:
        return eventName
    return ""

  def get_alt_names(oneName):
    dictionary = EVENT.alt_names_dict
    if oneName in list(dictionary):
      return dictionary[oneName]
    for eventName in dictionary:
      if oneName.upper() in dictionary[eventName]:
        return dictionary[eventName]
    return []

  def __str__(self):
    return (str(self.distance) + " " + self.stroke)

  def __eq__(self, other):
    return (self.distance == other.distance and self.stroke == other.stroke)
  #end of EVENT class

class SWIMTIME:
  minute = 0
  second = 0
  centisecond = 0
  isNoTime = True

  def __init__(self, parameters):
    #Reset to NT object
    self.minute = 0
    self.second = 0
    self.centisecond = 0
    self.isNoTime = True

    #The SWIMTIME constructor is designed to take one parameter.
    #It separates the process of initializing the object into three cases:
    #a string argument,
    #a floating-point number argument,
    #or a list argument.
    #It can create a swim time from any of these.

    #Case 1: string argument
    if type(parameters) is str:
      colonIdx = parameters.find(":")             # Find where special characters separate these numbers
      periodIdx = parameters.find(".")
      #Case 1A: both : and . are found
      if colonIdx != -1 and periodIdx != -1:
        self.minute = int(parameters[:colonIdx])
        self.second = int(parameters[colonIdx+1:periodIdx].rjust(2,"0"))
        if(parameters[periodIdx+1] == "-"):                                           # These lines ensure
          self.centisecond = int(parameters[periodIdx+1:periodIdx+4].ljust(2,"0"))    # that decimal times
        else:                                                                         # are truncated to
          self.centisecond = int(parameters[periodIdx+1:periodIdx+3].ljust(2,"0"))    # 2 decimal places.
        self.isNoTime = False
        self.adjustTime()
      #Case 1B: a . is found, but no :
      elif periodIdx != -1:
        self.minute = 0
        self.second = int(parameters[:periodIdx].rjust(2,"0"))
        if(parameters[periodIdx+1] == "-"):
          self.centisecond = int(parameters[periodIdx+1:periodIdx+4].ljust(2,"0"))
        else:
          self.centisecond = int(parameters[periodIdx+1:periodIdx+3].ljust(2,"0"))
        self.isNoTime = False
        self.adjustTime()
      #Case 1C: a : is found, but no .
      elif colonIdx != -1:
        self.minute = int(parameters[:colonIdx])
        self.second = int(parameters[colonIdx+1:])
        self.centisecond = 0
        self.isNoTime = False
        self.adjustTime()
    #Case 2: floating-point number argument
    elif type(parameters) is float:
      #Case 2A: the time is nonnegative
      if(parameters>=0):
        wholeSeconds = parameters // 1                # Separating whole seconds...
        decimal = parameters % 1                      # ...from fractions of a second
        floorDecimalTimes100 = (decimal * 100) // 1
        wholeMinutes = wholeSeconds // 60             # Separating whole minutes...
        extraSeconds = wholeSeconds % 60              # ...from fractions of a minute
        self.minute = int(wholeMinutes)
        self.second = int(extraSeconds)               # Set all four instance variables
        self.centisecond = int(floorDecimalTimes100)  # to the calculated values
        self.isNoTime = False
      #Case 2B: the time is negative
      else:
        parameters = -1 * parameters                  # Handle exactly the same as
        wholeSeconds = parameters // 1                # the nonnegative time,
        decimal = parameters % 1                      # except that we multiply by
        floorDecimalTimes100 = (decimal * 100) // 1   # -1 at the start and at the
        wholeMinutes = wholeSeconds // 60             # end multiply each instance
        extraSeconds = wholeSeconds % 60              # variable by -1.
        self.minute = -1 * int(wholeMinutes)
        self.second = -1 * int(extraSeconds)
        self.centisecond = -1 * int(floorDecimalTimes100)
        self.isNoTime = False

    #Case 3: list argument
    elif type(parameters) is list and len(parameters) == 4:
      #Each item of the list corresponds to one instance variable
      self.minute = parameters[0]
      self.second = parameters[1]
      self.centisecond = parameters[2]
      self.isNoTime = parameters[3]

  def adjustTime(self):                 # Method used to correct times with...
    while(self.centisecond >= 100):     # ...more than 100 centiseconds or...
      self.centisecond -= 100
      self.second += 1
    while(self.second >= 60):           # ...more than 60 seconds.
      self.second -= 60
      self.minute += 1

  def __float__(self):             # Converts the SWIMTIME to floating-point number
    return (self.minute * 60.0 + self.second + self.centisecond * 0.01)

  def __str__(self):               # Converts the SWIMTIME to a string
    if (self.isNoTime):
      return "NT"
    minuteString = str(self.minute)
    secondString = str(self.second).rjust(2,"0")
    centisecondString = str(self.centisecond).rjust(2,"0")
    return (minuteString + ":" + secondString + "." + centisecondString)

  def __eq__(self,other):         # Defines == operator
    if other == None:
      return False
    if(self.isNoTime == True or other.isNoTime == True):
      if(self.isNoTime == True and other.isNoTime == True):
        return True
      else:
        return False
    else:
      return (self.minute == other.minute and self.second == other.second and self.centisecond == other.centisecond)

  def __add__(self,other):        # Defines + operator
    return SWIMTIME(float(self) + float(other))

  def __sub__(self,other):        # Defines - operator
    return SWIMTIME(float(self) - float(other))

  def __truediv__(self,other):    # Defines / operator (returns float)
    if other == None:
      return 0
    if other.isNoTime == True:
      return 0
    if self.isNoTime:
      return float('inf')
    return float(self)/float(other)

  def __mul__(self,other):        # Defines * operator (multiply by a float, returns SWIMTIME)
    if type(other) is not float and type(other) is not int:
      return None
    return SWIMTIME(float(self) * other)

  def __lt__(self,other):         # Defines < operator
    if other == None:
      return True
    if other.isNoTime:
      return True
    if self.isNoTime:
      return False
    return float(self) < float(other)

  def __gt__(self,other):         # Defines > operator
    if other == None:
      return False
    if other.isNoTime:
      return False
    if self.isNoTime:
      return True
    return float(self) > float(other)
  #end of SWIMTIME class

class SWIMMER:
  name = "Unknown Swimmer"
  age = None
  team_MCPS = "Unattached"
  team_USA = "Unattached"
  nicknames = []

  def __init__(self, parameters):
    name = "Unknown Swimmer"
    age = None
    team_MCPS = "Unattached"
    team_USA = "Unattached"
    nicknames = []
    if type(parameters) is str:
      self.name = parameters
    elif type(parameters) is list and len(parameters) >= 2:
      self.name = parameters[0]
      self.age = parameters[1]
      if len(parameters) >= 3:
        self.team_MCPS = parameters[2]
        if len(parameters) >= 4:
          self.team_USA = parameters[3]
          if len(parameters) == 5:
            self.nicknames = parameters[4]

  def addNickname(self, nickname):
    self.nicknames.append(nickname)

  def __str__(self):
    if self.age == None:
      return self.name
    if self.team_MCPS == "Unattached":
      return (self.name + " (Age " + str(self.age) + ")")
    return (self.name + " (Age " + str(self.age) + " Team " + self.team_MCPS + ")")

  def __eq__(self,other):
    if other == None:
      return False
    if not (self.name == other.name or self.name in other.nicknames or other.name in self.nicknames):
      return False
    if self.age != None and other.age != None and self.age != other.age:
      return False
    if self.team_MCPS != "Unattached" and other.team_MCPS != "Unattached" and self.team_MCPS != other.team_MCPS:
      return False
    if self.team_USA != "Unattached" and other.team_USA != "Unattached" and self.team_USA != other.team_USA:
      return False
    return True

  def __ge__(self,other):
    if other == None:
      return False
    if not (self.name == other.name or self.name in other.nicknames or other.name in self.nicknames):
      return False
    if self.age != other.age or self.team_MCPS != other.team_MCPS or  self.team_USA != other.team_USA:
      return False
    return True

  #end of SWIMMER class

class TIMEARCHIVE:
  swimmer = None
  swimtime = SWIMTIME("NT")
  event = None
  teamrank = None
  selfpower = None
  selfpowerrank = None

  def __init__(self, swr, stm, ev):
    if type(swr) is str:
      self.swimmer = SWIMMER(swr)
    elif type(swr) is SWIMMER:
      self.swimmer = swr

    if type(stm) is str:
      self.swimtime = SWIMTIME(stm)
    elif type(stm) is SWIMTIME:
      self.swimtime = stm

    if type(ev) is str:
      self.event = EVENT(ev)
    elif type(ev) is EVENT:
      self.event = ev

  def __eq__(self,other):
    if other == None:
      return False
    return(self.swimmer == other.swimmer and self.swimtime == other.swimtime and self.event == other.event)

  def __str__(self):
    return(str(self.swimmer) + " " + str(self.event) + " (" + str(self.swimtime) + ")")

  def isNoTime(self):
    return self.swimtime.isNoTime

  def rankString(self):
    if self.teamrank == None:
      return "?"
    elif type(self.teamrank) is int:
      return self.teamrank
    return "?"

  def __lt__(self,other):
    if other == None:
      return True
    return self.swimtime < other.swimtime

  def __gt__(self,other):
    if other == None:
      return False
    return self.swimtime > other.swimtime

  #end of TIMEARCHIVE class

class ENTRY3:
  idxNum = 0
  event = None
  entry_List = [None,None,None] #must be length 3

  def __init__(self,event):
    if type(event) is str:
      self.event = EVENT(event)
    elif type(event) is EVENT:
      self.event = event
    self.reset()

  def __str__(self):
    tabWidth = 20
    if(self.idxNum == 0):
      line1 = str(self.event).ljust(tabWidth)
    else:
      line1 = (str(self.idxNum) + " " + str(self.event)).ljust(tabWidth)
    line2 = (" " * tabWidth)

    for entry in self.entry_List:
      if(entry == None):
        line1 += ("[EMPTY]").ljust(tabWidth)
        line2 += ("(_:__._)").ljust(math.ceil(tabWidth * 0.6)) + ("(_)").ljust(math.floor(tabWidth * 0.4))
      elif type(entry) is TIMEARCHIVE:
        nameString = str(entry.swimmer.name)[:tabWidth]
        timeString = "(" + str(entry.swimtime) + ")"
        rankString = "(" + str(entry.rankString()) + ")"
        line1 += nameString.ljust(tabWidth)
        line2 += timeString.ljust(math.ceil(tabWidth * 0.6)) + rankString.ljust(math.floor(tabWidth * 0.4))
    return line1 + "\n" + line2

  def __hash__(self):
    return hash(repr(self))

  def reset(self):
    self.entry_List = [None,None,None]

  def addTAR(self,tar):
    if type(tar) is not TIMEARCHIVE:
      return False
    if not None in self.entry_List:
      return False
    if tar.event != self.event:
      return False
    for idx in range(len(self.entry_List)):
      if self.entry_List[idx] == None:
        self.entry_List[idx] = tar
        return True

  def removeTAR(self, tar):
    if type(tar) is not TIMEARCHIVE:
      return False
    if tar.event != self.event:
      return False
    for idx in range(len(self.entry_List)):
      if self.entry_List[idx] == tar:
        self.entry_List[idx] = None
        return True
    return False

  def removeSWR(self, swr):
    if type(swr) is not SWIMMER:
      return False
    for idx in range(len(self.entry_List)):
      if self.entry_List[idx] != None:
        if self.entry_List[idx].swimmer == swr:
          self.entry_List[idx] = None
          return True
    return False

  def getSWRs(self):
    returnList = []
    for entry in self.entry_List:
      if entry == None:
        returnList.append(None)
      else:
        returnList.append(entry.swimmer)
    return returnList

  def sort(self):
    if len(self.entry_List) != 3:
      return
    self.entry_List = sorted(self.entry_List)

  def __eq__(self,other):
    return False

  def __contains__(self,other):
    if other == None:
      for entry in self.entry_List:
        if entry == None:
          return True
    if type(other) is str:
      for swr in self.getSWRs():
        if swr == SWIMMER(other):
          return True
    elif type(other) is SWIMMER:
      for swr in self.getSWRs():
        if swr == other:
          return True
    elif type(other) is TIMEARCHIVE:
      for tar in self.entry_List:
        if tar == other:
          return True
    return False

  def fillUp(self):
    count = 0
    for entry in self.entry_List:
      if entry != None:
        count += 1
    return count

  #end of ENTRY3 class

class RELAY3:
  idxNum = 0
  event = None
  leg_List = [None,None,None,None] #must be length 4
  letters = []

  def __init__(self, event):
    if type(event) is str:
      self.event = EVENT(event)
    elif type(event) is EVENT:
      self.event = event
    self.reset()

    self.letters = ["a", "b", "c", "d", "e", "f"]
    if self.event == EVENT("200 Medley Relay"):
      self.letters = ["bk", "br", "fl", "fr", "#", "#"]

  def __str__(self):
    tabWidth = 20
    lines = []

    for idx in range(len(self.leg_List)):
      lines.append("")

      if idx == 0:
        if(self.idxNum == 0):
          lines[idx] = (self.letters[idx] + " " + str(self.event)).ljust(tabWidth)
        else:
          lines[idx] = (str(self.idxNum) + self.letters[idx] + " " + str(self.event)).ljust(tabWidth)
      else:
        if(self.idxNum == 0):
          lines[idx] = self.letters[idx] + (" " * (tabWidth-len(self.letters[idx])))
        else:
          lines[idx] = str(self.idxNum) + self.letters[idx] + (" " * (tabWidth-1-len(self.letters[idx])))

      if self.leg_List[idx] == None:
        lines[idx] = lines[idx] + (("[EMPTY]").ljust(tabWidth) * 3)
      else:
        for entry in self.leg_List[idx].entry_List:
          if(entry == None):
            lines[idx] = lines[idx] + ("[EMPTY]").ljust(tabWidth)
          elif type(entry) is TIMEARCHIVE:
            nameString = str(entry.swimmer.name)
            lines[idx] += nameString[:tabWidth].ljust(tabWidth)

    returnString = ""
    for idx in range(len(lines)):
      returnString += lines[idx]
      if idx + 1 != len(lines):
        returnString += "\n"
    return returnString

  def __hash__(self):
    return hash(repr(self))

  def reset(self):
    self.leg_List = [None,None,None,None]

  def resetLegs(self):
    for leg in self.leg_List:
      leg.reset()

  def initLegs(self, legs_names):
    if type(legs_names) is not list:
      if type(legs_names) is str:
        self.leg_List = [ENTRY3(legs_names), ENTRY3(legs_names), ENTRY3(legs_names), ENTRY3(legs_names)]
      elif type(legs_names) is ENTRY3:
        self.leg_List = [legs_names,legs_names,legs_names,legs_names]
      return
    for idx in range(len(legs_names)):
      leg_n = legs_names[idx]
      if type(leg_n) is str:
        self.leg_List[idx] = ENTRY3(leg_n)
      elif type(leg_n) is ENTRY3:
        self.leg_List[idx] = leg_n

  def addTAR(self, leg_idx, tar):
    if type(leg_idx) == str:
      leg_idx = self.letters.index(leg_idx)
    if self.leg_List[leg_idx] == None:
      return False
    return self.leg_List[leg_idx].addTAR(tar)

  def removeTAR(self, leg_idx, tar):
    if type(leg_idx) == str:
      leg_idx = self.letters.index(leg_idx)
    if self.leg_List[leg_idx] == None:
      return False
    return self.leg_List[leg_idx].removeTAR(tar)

  def removeSWR(self, leg_idx, swr):
    if type(leg_idx) == str:
      leg_idx = self.letters.index(leg_idx)
    if self.leg_List[leg_idx] == None:
      return False
    return self.leg_List[leg_idx].removeSWR(swr)

  def removeAllSWR(self, swr):
    for leg in self.leg_List:
      if leg == None:
        return False
      return leg.removeSWR(swr)

  def relayTeams(self):
    returnList = [[None,None,None,None],[None,None,None,None],[None,None,None,None]]
    for leg_idx in range(len(self.leg_List)):
      if self.leg_List[leg_idx] != None:
        for team_idx in range(len(self.leg_List[leg_idx].entry_List)):
          team_entry = self.leg_List[leg_idx].entry_List[team_idx]
          returnList[team_idx][leg_idx] = team_entry
    return returnList

  def addTeamTARs(self, teamtars):
    if type(teamtars) is not list:
      return False
    if len(teamtars) != 4:
      return False
    emptyTeam = -1
    for team in range(len(self.leg_List[0].entry_List)):
      isEmpty = True
      for leg in self.leg_List:
        if leg.entry_List[team] != None:
          isEmpty = False
      if isEmpty:
        emptyTeam = team
        break
    if emptyTeam == -1:
      return False

    for idx in range(len(teamtars)):
      tar = teamtars[idx]
      if tar.event != self.leg_List[idx].event:
        return False
      self.leg_List[idx].entry_List[emptyTeam] = tar
    return True

  def removeTeamTARs(self, teamtars):
    idx = -1
    successFail = True
    for tar in teamtars:
      idx += 1
      sF = self.removeTAR(idx, tar)
      if not sF:
        successFail = False
    return successFail

  def __contains__(self,other):
    for leg in self.leg_List:
      if other in leg:
        return True
    return False

  #end of RELAY3 class

class LINEUP:
  name = ""
  entries = {}
  relayentries = {}

  def __init__(self, name, events, relayevents):
    self.reset()
    self.name = name
    idxNum = 0
    for relayevent in relayevents:
      if type(relayevent) is EVENT:
        myKey = relayevent
      elif type(relayevent) is str:
        myKey = EVENT(relayevent)

      self.relayentries[myKey] = RELAY3(myKey)
      idxNum += 1
      self.relayentries[myKey].idxNum = idxNum
      if myKey == EVENT("200 Free Relay"):
        self.relayentries[myKey].initLegs("50 Free")
      elif myKey == EVENT("400 Free Relay"):
        self.relayentries[myKey].initLegs("100 Free")
      elif myKey == EVENT("200 Medley Relay"):
        #self.relayentries[myKey].initLegs(["50 Back", "50 Breast", "50 Fly", "50 Free"])
        self.relayentries[myKey].initLegs(["100 Back", "100 Breast", "100 Fly", "100 Free"])

    for event in events:
      if type(event) is EVENT:
        myKey = event
      elif type(event) is str:
        myKey = EVENT(event)

      self.entries[myKey] = ENTRY3(myKey)
      idxNum += 1
      self.entries[myKey].idxNum = idxNum

  def __str__(self):
    tabWidth = 20
    returnString = self.name
    returnString += "\n\n" + "." + ("_" * tabWidth * 4) + "."
    returnString += "\n" + "|" + ("# EVENT NAME").ljust(tabWidth) + ("ENTRY 1").ljust(tabWidth) + ("ENTRY 2").ljust(tabWidth) + ("ENTRY 3").ljust(tabWidth) + "|"
    returnString += "\n" + "|" + (" " * tabWidth) + (("(TIME)").ljust(math.ceil(tabWidth * 0.6)) + ("(RANK)").ljust(math.floor(tabWidth * 0.4))) * 3 + "|"

    for relayentry in self.relayentries:
      returnString += "\n" + "|" + ("_" * tabWidth * 4) + "|"
      for line in (str(self.relayentries[relayentry])).splitlines():
        returnString += "\n" + "|" + line + "|"

    for entry in self.entries:
      returnString += "\n" + "|" + ("_" * tabWidth * 4) + "|"
      for line in (str(self.entries[entry])).splitlines():
        returnString += "\n" + "|" + line + "|"

    returnString += "\n" + "|" + ("_" * tabWidth * 4) + "|"
    return returnString

  def reset(self):
    self.name = ""
    self.entries = {}
    self.relayentries = {}

  def add(self,event,tar):
    if type(event) is EVENT:
      EV = event
    elif type(event) is str:
      EV = EVENT(event)

    for entry in self.entries:
      if entry == EV:
        if not tar in self.entries[entry]:
          successFail = self.entries[entry].addTAR(tar)
          if not None in self.entries[entry].entry_List:
            self.entries[entry].sort()
          return successFail

    for relayentry in self.relayentries:
      if relayentry == EV:
        if type(tar) is list:
          #if not tar in self.relayentries[relayentry]:
          return self.relayentries[relayentry].addTeamTARs(tar)

    return False

  def remove(self, event, tar):
    if type(event) is EVENT:
      EV = event
    elif type(event) is str:
      EV = EVENT(event)
    else:
      print(event)
      print(type(event))

    for entry in self.entries:
      if entry == EV:
        return self.entries[entry].removeTAR(tar)

    for relayentry in self.relayentries:
      if relayentry == EV:
        if type(tar) is list:
          return self.relayentries[relayentry].removeTeamTARs(tar)

    return False

  def addinrelay(self,event,leg,tar):
    if type(event) is EVENT:
      EV = event
    elif type(event) is str:
      EV = EVENT(event)

    for relayentry in self.relayentries:
      if relayentry == EV:
        if not tar.swimmer in self.relayentries[relayentry]:
          return self.relayentries[relayentry].addTAR(leg,tar)
    return False

  def removeinrelay(self,event,leg,tar):
    if type(event) is EVENT:
      EV = event
    elif type(event) is str:
      EV = EVENT(event)

    for relayentry in self.relayentries:
      if relayentry == EV:
        return self.relayentries[relayentry].removeTAR(leg,tar)

  def evByIdx(self,idxNum):
    for ev in self.entries:
      if self.entries[ev].idxNum == idxNum:
        return ev
    for rev in self.relayentries:
      if self.relayentries[rev].idxNum == idxNum:
        return rev
    return None

  def fillUpIndiv(self):
    minFull = 3
    for e in self.entries:
      entryFillUp = self.entries[e].fillUp()
      if entryFillUp < minFull:
        minFull = entryFillUp
    return minFull

  def fillUpEvent(self, event):
    if type(event) is EVENT:
      EV = event
    elif type(event) is str:
      EV = EVENT(event)

    for entry in self.entries:
      if entry == EV:
        return self.entries[entry].fillUp()

  #end of LINEUP class

class selfpower:
  selfpower = float('inf')
  def __init__(self, sp):
    self.selfpower = sp
  def __float__(self):
    return float(selfpower)
  def __lt__(self,other):
    if other == None:
      return True
    if self.selfpower == None:
      return False
    if other.selfpower == None:
      return True
    return self.selfpower < other.selfpower

class TARLOOKUP:
  swimmerlist = []
  tardict = {}

  def __init__(self, swrsArg, evsArg):
    self.reset()
    swrs = list(swrsArg)
    evs = list(evsArg)
    for x in range(len(swrs)):
      if type(swrs[x]) is not SWIMMER:
        swrs[x] = SWIMMER(swrs[x])
    for y in range(len(evs)):
      if type(evs[y]) is not EVENT:
        evs[y] = EVENT(evs[y])

    self.swimmerlist = swrs
    for ev in evs:
      self.tardict[ev] = []
      for swr in swrs:
        self.tardict[ev].append(TIMEARCHIVE(swr,"NT",ev))

  def __str__(self):
    returnString = ""
    tabWidth = 20
    returnString += (" " * tabWidth)
    for swimmer in self.swimmerlist:
      returnString += swimmer.name[:tabWidth].ljust(tabWidth)
    for ev in self.tardict:
      returnString += "\n"
      returnString += str(ev).ljust(tabWidth)
      for tar in self.tardict[ev]:
        if tar == None:
          returnString += "error".ljust(tabWidth)
        else:
          returnString += str(tar.swimtime).ljust(tabWidth)
    return returnString

  def reset(self):
    self.swimmerlist = []
    self.tardict = {}

  def specify(self, swrArgs, evArgs, stm):
    swri = -1
    if type(swrArgs) is not SWIMMER:
      swr = SWIMMER(swrArgs)
    else:
      swr = swrArgs
    if type(evArgs) is not EVENT:
      ev = EVENT(evArgs)
    else:
      ev = evArgs

    for swimmeridx in range(len(self.swimmerlist)):
      if self.swimmerlist[swimmeridx] == swr:
        swri = swimmeridx
        break
    if swri == -1:
      return
    for event in self.tardict:
      if event == ev:
        self.tardict[event][swri] = TIMEARCHIVE(swr,stm,ev)

  def lookup(self, swrArgs, evArgs):
    swri = -1
    if type(swrArgs) is not SWIMMER:
      swr = SWIMMER(swrArgs)
    else:
      swr = swrArgs
    if type(evArgs) is not EVENT:
      ev = EVENT(evArgs)
    else:
      ev = evArgs

    for swimmeridx in range(len(self.swimmerlist)):
      if self.swimmerlist[swimmeridx] == swr:
        swri = swimmeridx
        break
    if swri == -1:
      return
    for event in self.tardict:
      if event == ev:
        return self.tardict[event][swri]

  def getrank(self, swrArgs, evArgs):
    swri = -1
    if type(swrArgs) is not SWIMMER:
      swr = SWIMMER(swrArgs)
    else:
      swr = swrArgs
    if type(evArgs) is not EVENT:
      ev = EVENT(evArgs)
    else:
      ev = evArgs

    for swimmeridx in range(len(self.swimmerlist)):
      if self.swimmerlist[swimmeridx] == swr:
        swri = swimmeridx
        break
    if swri == -1:
      return
    for event in self.tardict:
      if event == ev:
        return sorted(self.tardict[event]).index(self.tardict[event][swri]) + 1

  def getselfpowerrank(self, swrArgs, evArgs):
    swri = -1
    if type(swrArgs) is not SWIMMER:
      swr = SWIMMER(swrArgs)
    else:
      swr = swrArgs
    if type(evArgs) is not EVENT:
      ev = EVENT(evArgs)
    else:
      ev = evArgs

    for swimmeridx in range(len(self.swimmerlist)):
      if self.swimmerlist[swimmeridx] == swr:
        swri = swimmeridx
        break
    if swri == -1:
      return

    allthisguystars = []
    for event in self.tardict:
      allthisguystars.append(self.tardict[event][swri])
    allthisguystars = sorted(allthisguystars, key = lambda tar: selfpower(tar.selfpower))
    for event in self.tardict:
      if event == ev:
        return allthisguystars.index(self.tardict[event][swri]) + 1

  def find_selfpowers(self, standardDict):
    for swri in range(len(self.swimmerlist)):
      standard = SWIMTIME("NT")
      for e in list(standardDict):
        standard = standardDict[e]
        if type(standard) is str or type(standard) is float:
          standard = SWIMTIME(standard)
        if type(e) is str:
          e = EVENT(e)
        for e2 in self.tardict:
          if e == e2:
            #print("Divide " + str(self.tardict[e2][swri].swimtime) + " by " + str(standard))
            self.tardict[e2][swri].selfpower = self.tardict[e2][swri].swimtime / standard

  def rankeverything(self):
    for ev in self.tardict:
      for swri in range(len(self.swimmerlist)):
        self.tardict[ev][swri].teamrank = self.getrank(self.swimmerlist[swri], ev)

  def selfpowerrankeverything(self):
    for ev in self.tardict:
      for swri in range(len(self.swimmerlist)):
        self.tardict[ev][swri].selfpowerrank = self.getselfpowerrank(self.swimmerlist[swri], ev)

  #end of TARLOOKUP class

"""# STSS

This is the Swim Time Scraping System. What it does is it takes the swimmer times from a website and a pdf and finds the fastest ones to put them in a tarlookup (a class that I defined) object.
"""

import requests as req
!pip install --upgrade gdown
import gdown
!pip install PyPDF2
import PyPDF2
from google.colab import drive
drive.mount('/content/drive/')

def pageText(swimmerNameArgument):
  # Given the name of a swimmer, returns HTML of a web page with his/her swim times.
  if type(swimmerNameArgument) is str:
    swimmerName = swimmerNameArgument
  elif type(swimmerNameArgument) is SWIMMER:        # We've got to make sure that
    swimmerName = swimmerNameArgument.name          # swimmer name is a string!
  nameFormatted = swimmerName.lower().replace(" ", "-")
  # swimstandards.com uses lowercase names with first and last name separated by a hyphen.
  getPage = req.get("https://swimstandards.com/swimmer/" + nameFormatted)
  # We have already imported requests under the name "req" and now we use its "get()" method.
  getPageAsText = getPage.text
  titlstr = titleString(getPageAsText)    # Call another function I wrote to isolate the title of the web page.
  if titlstr == "Not Found - Swim Standards":     # Checking to see if the swimmer is not found.
    return "Error"
  else:                                           # Otherwise, the swimmer has been found. Great!
    pageList = []                                 # We make a list containing the HTML for all web pages...
    pageList.append(getPageAsText)                # belonging to a swimmer with a name that matches our name.
    idxNum = 0
    while titlstr != "Not Found - Swim Standards":      # We keep looking until we find as many people with
      idxNum += 1                                       # the same name as possible.
      newName = nameFormatted + "-" + str(idxNum)
      getPage = req.get("https://swimstandards.com/swimmer/" + newName)
      getPageAsText = getPage.text
      titlstr = titleString(getPageAsText)
      if titlstr != "Not Found - Swim Standards":
        pageList.append(getPageAsText)
    if len(pageList) == 1:                          # If our list has only one page, we can return that.
      return pageList[0]
    else:                                           # Otherwise it means that a bunch of swimmers were found.
      print("Sorry, we found an ambiguity. Please input the number of the swimmer whose times you desire.")
      print("Or, input NOCLUB if the swimmer does not swim club swimming.")
      # We prompt the user to identify which swimmer matches the one whom they want to find.
      for idx in range(len(pageList)):
        print(str(idx) + ": " + titleString(pageList[idx]))     # We show them all their options.
      myidx = input("What is the number? ")                     # We ask them which one they want.
      if myidx.upper() == "NOCLUB":
        return "Error"                   # Acts the same as a "swimmer not found."
      else:
        myidx = int(myidx)               # Choose the one preferred by the user
        return pageList[myidx]           # and return it!

def titleString(pgText):    # This function finds a substring of the HTML...
  return pgText[pgText.find("<title>") + 7:pgText.find("</title>")] # that is labeled with a <title></title> tag.

def pageSwimsText(pgText):
  beginidx = 0
  endidx = 0
  swims = []
  while beginidx != -1:
    beginidx = pgText.find('"event":',beginidx+1)
    if beginidx != -1:
      endidx = pgText.find(',',pgText.find('"time"',beginidx))
      if endidx != -1:
        swims.append(pgText[beginidx:endidx])
  return swims

def pageSwimsTar(swimsTextList, swimmer):
  swims = []
  for singleSwimString in swimsTextList:
    if scrapeByKeyword(singleSwimString, '"type":') != "LCM":
      newTar = TIMEARCHIVE(swimmer, scrapeByKeyword(singleSwimString, '"time":'), scrapeByKeyword(singleSwimString, '"event":'))
      if newTar.swimtime != SWIMTIME(0.0):
        swims.append(newTar)
  return swims

def scrapeByKeyword(text, keyword):
  beginidx = text.find(keyword) + len(keyword) + 1
  endidx = text.find('"', beginidx)
  subString = text[beginidx:endidx]
  return subString

def swimmerObj(title):
  nameStartIdx = 0
  nameEndIdx = title.find("|",nameStartIdx)-1
  name = title[nameStartIdx:nameEndIdx]

  ageStartIdx = title.find("Age ") + 4
  ageEndIdx = title.find("|",ageStartIdx)-1
  age = int(title[ageStartIdx:ageEndIdx])

  teamStartIdx = title.find("(",ageEndIdx) + 1
  teamEndIdx = title.find(")",teamStartIdx)
  teamusa = title[teamStartIdx:teamEndIdx]

  newSwimmer = SWIMMER([name, age])
  newSwimmer.team_USA = teamusa

  return newSwimmer

def getAllUSAtars(name):
  tx = pageText(name)
  if tx != "Error":
    titlstr = titleString(tx)
    myswimmer = swimmerObj(titlstr)
    pstx = pageSwimsText(tx)
    pstar = pageSwimsTar(pstx,myswimmer)
    return pstar
  else:
    return []

def updateTarlookupUSA(tarlookup, name):
  allUSAtars = getAllUSAtars(name)
  for USAtar in allUSAtars:
    swr = USAtar.swimmer
    stm = USAtar.swimtime
    ev = USAtar.event
    if ev in list(tarlookup.tardict):
      if USAtar < tarlookup.lookup(swr,ev):
        tarlookup.specify(swr,ev,stm)

def downloadMCPScurrentSeason(filename):
  # Save this link forever!!! Never let it go!
  # https://drive.google.com/file/d/1IxCsyLoUYsM8HuNWfXYnNlaqLiG6P4C2/view
  #getPage = req.get("https://sites.google.com/mcpsmd.net/mcps-swim-dive/current-season")
  #getPageAsText = str(getPage.text)
  # Finding the web page where we know we can find a link to the public PDF

  #finderindex = getPageAsText.find("MCPS (All schools) Top Times")
  #aTagStart = getPageAsText.rfind("<a ", 0, finderindex)
  #aTagEnd = getPageAsText.find("</a>", finderindex) + 4
  #aTag = getPageAsText[aTagStart:aTagEnd]
  # Finding the <a></a> in the HTML and isolating it as a substring

  #hrefStart = aTag.find("href=\"") + 6
  #hrefEnd = aTag.find("\"",hrefStart)
  #href = aTag[hrefStart:hrefEnd]
  href = "https://drive.google.com/file/d/1IxCsyLoUYsM8HuNWfXYnNlaqLiG6P4C2/view"
  # Finding the link address in the <a></a> and isolating it as a substring

  idStart = href.find("/d/") + 3
  idEnd = href.find("/", idStart)
  id = href[idStart:idEnd]
  # Finding the Google Drive File ID in the link address and isolating it as a substring

  newURL = "https://drive.google.com/uc?id=" + id
  print("System is now downloading this document: " + newURL)
  gdown.download(newURL, filename)
  # Downloads the file into my runtime environment in Google Colab

def getAllMCPStars(filename, teamCode):
  # Function to get TIMEARCHIVE objects from MCPS public document
  # (a TIMEARCHIVE is essentially a collection of one SWIMTIME, one EVENT, and one SWIMMER)
  fileOpen = open(filename, 'rb')           # Opening the file based on filename, in binary format.
  pdfReader = PyPDF2.PdfReader(fileOpen)    # Create new PdfReader from the PyPDF2 module,
                                            # helping us read the file.

  eventName = ""            # Preparing to keep track of which event we are currently processing
  pageNum = 0               # Preparing to keep track of page numbers
  filterTeamCode = teamCode
  tarsList = []             # This is what is to be returned
  for page in pdfReader.pages:
    pageNum += 1
    text = str(page.extract_text())
    lines = text.splitlines()
    # We now have a list of all the lines on the page.
    for line in lines:
      if "Boys" in line or "Girls" in line:
        words = line.split()
        eventName = words[1] + " " + words[2]
        # The event has just changed! We must keep track of this every time we see "Boys" or "Girls."
        # This is because the PDF has lines saying things like "Boys 50 Free" or "Girls 100 Breast".

      elif filterTeamCode in line and eventName != "1 Meter":
        # This elif makes sure that in the following lines we only consider swimming events, not diving events
        # It also makes sure that the team we are trying to investigate is mentioned on that line.
        post_vs_idx = line.find("vs") + 6       # However, it could be that we get data from when another team swam
        trimmedLine = line[post_vs_idx:]        # against our team. Hence, if we are searching for the team "RMT,"
                                                # a line containing team "MTB"'s data may appear with a substring
                                                # "RMT vs MTB" at the front of it.
                                                # This trimmedLine variable lets us eliminate the ambiguity
                                                # and make sure we only get data that is from RMT swimmers.
        if filterTeamCode in trimmedLine:
          words = trimmedLine.split()
          teamCodeIdx = words.index(filterTeamCode)
          name = words[teamCodeIdx + 1] + " " + words[teamCodeIdx + 2]    # Grab the swimmer name
          wordsLen = len(words)
          time = words[wordsLen -3]                                       # Grab the swimmer time
          if "x" in time:
            time = time[1:]
          # We just extracted data about the swim so that we can turn it into a TIMEARCHIVE.
          swr = SWIMMER(name)
          swr.team_MCPS = teamCode      # Specify that the swimmer's team is the one we have chosen.
          stm = SWIMTIME(time)
          ev = EVENT(eventName)
          tarsList.append(TIMEARCHIVE(swr,stm,ev))
          # Into the list which is to be returned, add new TIMEARCHIVE with swimmer, time, and event.

  # closing the pdf file object
  fileOpen.close()
  return tarsList

def getAllSwimmers(filename,teamCode,boys):

  fileOpen = open(filename, 'rb')
  pdfReader = PyPDF2.PdfReader(fileOpen)

  gender = ""
  eventName = ""
  pageNum = 0
  filterTeamCode = teamCode
  swrList = []
  for page in pdfReader.pages:
    pageNum += 1
    text = str(page.extract_text())
    lines = text.splitlines()
    #print(str(pageNum) + ": " + str(lines))
    for line in lines:
      if "Boys" in line or "Girls" in line:
        words = line.split()
        gender = words[0]
        eventName = words[1] + " " + words[2]
      elif filterTeamCode in line and eventName != "1 Meter" and ((gender == "Boys" and boys == True) or (gender == "Girls" and boys == False)):
        post_vs_idx = line.find("vs") + 6
        trimmedLine = line[post_vs_idx:]
        if filterTeamCode in trimmedLine:
          words = trimmedLine.split()
          teamCodeIdx = words.index(filterTeamCode)
          name = words[teamCodeIdx + 1] + " " + words[teamCodeIdx + 2]
          swr = SWIMMER(name)
          swr.team_MCPS = teamCode
          if swr not in swrList:
            swrList.append(swr)
  return sorted(swrList, key = (lambda swr: swr.name))

def updateTarlookupMCPS(tarlookup, filename, team):
  allMCPStars = getAllMCPStars(filename, team)
  for MCPStar in allMCPStars:
    swr = MCPStar.swimmer
    stm = MCPStar.swimtime
    ev = MCPStar.event
    if ev in list(tarlookup.tardict):
      if MCPStar < tarlookup.lookup(swr,ev):
        tarlookup.specify(swr,ev,stm)

def writeTarlookupCSV(tarlookup, filepath, filename):
  if not filepath[0] == "/":
    filepath = "/" + filepath
  if not "/MyDrive" in filepath:
    filepath = "/MyDrive" + filepath
  if not "/content/drive" in filepath:
    filepath = "/content/drive" + filepath
  if not filepath[len(filepath) - 1] == "/":
    filepath = filepath + "/"
  try:
    fileOpen = open(filepath + filename + ".csv", "x")
  except:
    fileOpen = open(filepath + filename + ".csv", "w")

  fileOpen.write(",")

  eventidx = 0
  for event in list(tarlookup.tardict):
    eventidx += 1
    if eventidx == len(list(tarlookup.tardict)):
      fileOpen.write(str(event))
    else:
      fileOpen.write(str(event) + ",")

  fileOpen.write("\n")

  for swimmer in tarlookup.swimmerlist:
    fileOpen.write(swimmer.name + ",")
    eventidx = 0
    for event in list(tarlookup.tardict):
      eventidx += 1
      timeString = str(tarlookup.lookup(swimmer,event).swimtime)
      if timeString == "NT":
        timeString = ""
      if eventidx == len(list(tarlookup.tardict)):
        fileOpen.write(timeString)
      else:
        fileOpen.write(timeString + ",")
    fileOpen.write("\n")

  #The following code will transpose the sheet to be oriented the other way.
  # swimmeridx = 0
  # for swimmer in tarlookup.swimmerlist:
  #   swimmeridx += 1
  #   if swimmeridx == len(tarlookup.swimmerlist):
  #     fileOpen.write(swimmer.name)
  #   else:
  #     fileOpen.write(swimmer.name + ",")

  # fileOpen.write("\n")

  # for event in list(tarlookup.tardict):
  #   fileOpen.write(str(event) + ",")
  #   swimmeridx = 0
  #   for swimmer in tarlookup.swimmerlist:
  #     swimmeridx += 1
  #     if swimmeridx == len(tarlookup.swimmerlist):
  #       fileOpen.write(str(tarlookup.lookup(swimmer,event).swimtime))
  #     else:
  #       fileOpen.write(str(tarlookup.lookup(swimmer,event).swimtime) + ",")
  #   fileOpen.write("\n")

  fileOpen.close()

def readTarlookupCSV(filepath, filename):
  if not filepath[0] == "/":
    filepath = "/" + filepath
  if not "/MyDrive" in filepath:
    filepath = "/MyDrive" + filepath
  if not "/content/drive" in filepath:
    filepath = "/content/drive" + filepath
  if not filepath[len(filepath) - 1] == "/":
    filepath = filepath + "/"
  try:
    fileOpen = open(filepath + filename + ".csv", "r")
  except:
    return

  rows = fileOpen.read().splitlines()
  for rowidx in range(len(rows)):
    rows[rowidx] = rows[rowidx].split(",")

  events = rows[0][1:]
  swimmers = []
  for row in rows[1:]:
    swimmers.append(row[0])

  newtl = TARLOOKUP(swimmers,events)
  for swridx in range(len(swimmers)):
    for evidx in range(len(events)):
      newtl.specify(swimmers[swridx], events[evidx], rows[swridx+1][evidx+1])

  newtl.rankeverything()

  return newtl
  fileOpen.close()

def readRoster(filepath,filename):
  if not filepath[0] == "/":
    filepath = "/" + filepath
  if not "/MyDrive" in filepath:
    filepath = "/MyDrive" + filepath
  if not "/content/drive" in filepath:
    filepath = "/content/drive" + filepath
  if not filepath[len(filepath) - 1] == "/":
    filepath = filepath + "/"
  try:
    fileOpen = open(filepath + filename + ".csv", "r")
  except:
    return

  rows = fileOpen.read().splitlines()
  for rowidx in range(len(rows)):
    rows[rowidx] = rows[rowidx].split(",")

  swrList = []
  for row in rows:
    for cell in row:
      if cell != "":
        swrList.append(cell)

  return swrList

def stss_get_tarlookup():
  print("Enter the team code of your team (e.g. RMT for Richard Montgomery)")
  teamCode = input()
  print("Choose how you are getting the time spreadsheet")
  print("1. Upload from Google Drive")
  print("2. Scrape the archives for times")
  #print("3. Upload from Google Drive and update if any times were faster in the archives")
  tarSource = input()
  returntl = None

  if tarSource == "1" or tarSource == "3":
    print("\nPlease enter a path through your Google Drive to get to the folder desired.")
    print("Example: \"/folder/subfolder/subfolder/\"")
    filepath = input()
    print("Please enter the filename of the file with the time spreadsheet.")
    print("Please note the file requirements:")
    print(" - Must be in .csv format")
    print(" - Columns represent events with the first row containing all the event names.")
    print(" - Rows represent swimmers with the first column containing all the swimmer names.")
    print(" - Each other cell has one swim time in it.")
    print(" - The cell A1 is blank / not used.")
    print(" - do not include \".csv\" in the filename, we will add that automatically")
    filename = input()
    returntl = readTarlookupCSV(filepath, filename)
    returntl.rankeverything()
    return returntl
  if tarSource == "2" or tarSource == "3":
    downloadMCPScurrentSeason("mcpstoptimes.pdf")
    print("\nChoose how you are getting the swimmer names")
    print("1. Upload from Google Drive")
    print("2. Find all swimmers by team code (e.g. RMT) in 2023-2024 season")
    print("3. A single individual swimmer although I don't know why you would want to do that")
    nameSource = input()
    if nameSource == "1":
      print("\nPlease enter a path through your Google Drive to get to the folder desired.")
      print("Example: \"/folder/subfolder/subfolder/\"")
      filepath = input()
      print("Please enter the filename of the file with the swimmer names.")
      print("Please note the file requirements:")
      print(" - Must be in .csv format")
      print(" - Each name must be in one cell")
      print(" - do not include \".csv\" in the filename, we will add that automatically")
      filename = input()
      mynames = readRoster(filepath,filename)
    elif nameSource == "2":
      gender = input("Do you want boys or girls times? Write \"boys\" or \"girls\". Make sure to spell it correctly.")
      if gender.lower() == "boys":
        mynames = getAllSwimmers("mcpstoptimes.pdf", teamCode, True)
      else:
        mynames = mynames = getAllSwimmers("mcpstoptimes.pdf", teamCode, False)
    elif nameSource == "3":
      mynames = [input("Enter the name of the swimmer whose times you desire\n")]
    myevents = ["200 Free",
            "200 IM",
            "50 Free",
            "100 Fly",
            "100 Free",
            "500 Free",
            "100 Back",
            "100 Breast"]
    returntl = TARLOOKUP(mynames,myevents)
    for myname in mynames:
      updateTarlookupUSA(returntl,myname)
    updateTarlookupMCPS(returntl, "mcpstoptimes.pdf", teamCode)
    returntl.rankeverything()
    toDownload = input("Do you want to download the time spreadsheet?\nInput \"yes\" to put it in your Google Drive.\nInput nothing to skip.\n")
    if toDownload.lower() == "yes":
      print("\nPlease enter a path through your Google Drive to get to the folder desired.")
      print("Example: \"/folder/subfolder/subfolder/\"")
      filepath = input()
      writeTarlookupCSV(returntl, filepath, "auto-generated times " + teamCode)
    return returntl

"""# LIS

This is the Lineup Interface System. What it does is it lets you make a lineup. Much of the foundation of this is laid in the OOP stuff where I defined a Lineup class.
"""

from google.colab import output

def clearScreen():
  output.clear()

def ConstructNewMCPSLineup(name):
  return LINEUP(name, ["200 Free",
                                      "200 IM",
                                      "50 Free",
                                      "100 Fly",
                                      "100 Free",
                                      "500 Free",
                                      "100 Back",
                                      "100 Breast"],
                                     ["200 Medley Relay",
                                      "200 Free Relay",
                                      "400 Free Relay"])

def ConstructNewEventCount(tarlookup):
  array = []
  for swr in list(tarlookup.swimmerlist):
    array.append([swr, 0, 0, 0])
    #0 is swimmer
    #1 is individual count
    #2 is relay count
    #3 is total count
  return array

def ZeroEventCount(eventcount):
  for x in range(len(eventcount)):
    eventcount[x][1] = 0
    eventcount[x][2] = 0
    eventcount[x][3] = 0

def changeCountIndiv(eventcount, name, delta):
  if type(name) is SWIMMER:
    swr = name
  else:
    swr = SWIMMER(name)
  for idx in range(len(eventcount)):
    if eventcount[idx][0] == swr:
      eventcount[idx][1] = eventcount[idx][1] + delta
      eventcount[idx][3] = eventcount[idx][3] + delta

def changeCountRelay(eventcount, name, delta):
  if type(name) is SWIMMER:
    swr = name
  else:
    swr = SWIMMER(name)
  for idx in range(len(eventcount)):
    if eventcount[idx][0] == swr:
      eventcount[idx][2] = eventcount[idx][2] + delta
      eventcount[idx][3] = eventcount[idx][3] + delta

def canAddIndiv(eventcount, name):
  if type(name) is SWIMMER:
    swr = name
  else:
    swr = SWIMMER(name)
  for idx in range(len(eventcount)):
    if eventcount[idx][0] == swr:
      return eventcount[idx][1] < 2 and eventcount[idx][3] < 4

def canAddRelay(eventcount, name):
  if type(name) is SWIMMER:
    swr = name
  else:
    swr = SWIMMER(name)
  for idx in range(len(eventcount)):
    if eventcount[idx][0] == swr:
      return eventcount[idx][2] < 3 and eventcount[idx][3] < 4

def PromptNextLineupCommand(lineup, eventcount):
  print(lineup)
  for oneeventcount in eventcount:
    name = str(oneeventcount[0])
    if oneeventcount[1] > 2:
      print("⚠️WARNING⚠️ ... " + name + " has too many individual events!")
    elif oneeventcount[2] > 3:
      print("⚠️WARNING⚠️ ... " + name + " has too many relay events!")
    elif oneeventcount[3] > 4:
      print("⚠️WARNING⚠️ ... " + name + " has too many events overall!")
  if isFull(lineup):
    print("The lineup is full!!!")
  print("MENU")
  print("(a) input “[event #] [swimmer name]“ to add a swimmer to an event \n\t\t(e.g. “4 Josiah Main”)")
  print("(b) input “-[event #] [swimmer name” to remove a swimmer from an event \n\t\t(e.g.) -4 Josiah Main")
  print("(c) input “S[event #] [swimmer name] S[event #] [swimmer name]” to swap two swimmers in two events \n\t\t(e.g. “S2 Graham Stelzer S3 Shad Frantz”)")
  print("(d) input “INDIV” to autofill as many individual events as possible")
  print("(e) input “INDIV 2.0” to autofill as many individual events as possible, but go for first place more often.")
  print("(f) input “RELAY” to autofill as many relay events as possible")
  print("(g) input “CLEAR” to delete everything")
  print("(h) input “DOWNLOAD” to download your lineup as .csv")
  print("(i) press enter without inputting anything to stop the program")
  print("*Note: events fill up from left to right, even relays, which I haven't figured out a good solution for yet.")
  return input()

def commandAddOrRemove_indiv(lineup, tarlookup, event, swrname, shouldAdd, eventcount):
  if shouldAdd == True:
    #Handle Add Case
    tar = tarlookup.lookup(swrname,event)
    successFail = lineup.add(event, tar)
    if successFail == True:
      changeCountIndiv(eventcount, swrname, 1)
      return "Successfully added " + swrname + "'s {" + str(tar) + "} to event " + str(event)
    if successFail == False:
      return "Failed to add " + swrname + "'s {" + str(tar) + "} to event " + str(event)
  else:
    #Handle Remove Case
    tar = tarlookup.lookup(swrname,event)
    successFail = lineup.remove(event, tar)
    if successFail == True:
      changeCountIndiv(eventcount, swrname, -1)
      return "Successfully removed " + swrname + "'s {" + str(tar) + "} from event " + str(event)
    if successFail == False:
      return "Failed to remove " + swrname + "'s {" + str(tar) + "} from event " + str(event)

def commandAddOrRemove_relay(lineup, tarlookup, legStr, event, swrname, sub_event, shouldAdd, eventcount):
  if shouldAdd == True:
    #Handle Add Case
    #lol
    tar = tarlookup.lookup(swrname,sub_event)
    successFail = lineup.addinrelay(event, legStr, tar)
    if successFail == True:
      changeCountRelay(eventcount, swrname, 1)
      return "Successfully added " + swrname + " into the " + str(legStr) + " leg of event " + str(event) + " based on time {" + str(tar) + "} in event " + str(sub_event)
    else:
      return "Failed to add " + swrname + " into the " + str(legStr) + " leg of event " + str(event) + " based on time {" + str(tar) + "} in event " + str(sub_event)
  else:
    #Handle Remove Case
    #lol
    tar = tarlookup.lookup(swrname,sub_event)
    successFail = lineup.removeinrelay(event, legStr, tar)
    if successFail == True:
      changeCountRelay(eventcount, swrname, -1)
      return "Successfully removed " + swrname + " from the " + legStr + " leg of event " + str(event) + " based on time {" + str(tar) + "} in event " + str(sub_event)
    else:
      return "Failed to remove " + swrname + " from the " + legStr + " leg of event " + str(event) + " based on time {" + str(tar) + "} in event " + str(sub_event)

def ExecCommand(lineup, tarlookup, command, eventcount):
  if command.upper() == "CLEAR":
    for ev in lineup.entries:
      lineup.entries[ev].reset()
    for rev in lineup.relayentries:
      lineup.relayentries[rev].resetLegs()
    ZeroEventCount(eventcount)
    return "cleared"
  if command.upper() == "INDIV":
    print("Please wait! This takes like 5 seconds or so.")
    autofill_individual(lineup, tarlookup, eventcount, False, False)
    return "did indiv"
  if command.upper() == "INDIV 2.0":
    print("Please wait! This takes like 5 seconds or so.")
    autofill_individual(lineup, tarlookup, eventcount, False, True)
    return "did indiv"
  if command.upper() == "RELAY":
    autofill_relay(lineup, tarlookup, eventcount, False)
    return "did relay"
  if command.upper() == "DOWNLOAD":
    print("\nPlease enter a path through your Google Drive to get to the folder desired.")
    print("Example: \"/folder/subfolder/subfolder/\"")
    filepath = input()
    filename = lineup.name
    writeLineupCSV(lineup, filepath, filename)
    return "downloaded"

  commandWords = command.split()
  if commandWords[0].isnumeric():
    print("Adding swimmer to event")
    idxNum = int(commandWords[0])
    event = lineup.evByIdx(idxNum)
    swrname = commandWords[1] + " " + commandWords[2]

    return commandAddOrRemove_indiv(lineup, tarlookup, event, swrname, True, eventcount)

  elif commandWords[0][0].isnumeric():
    print("Adding swimmer to relay event")
    idxNumStr = ""
    letter = 0
    while commandWords[0][letter].isnumeric():
      idxNumStr += commandWords[0][letter]
      letter += 1
    legStr = commandWords[0][letter:]
    idxNum = int(idxNumStr)
    event = lineup.evByIdx(idxNum)
    swrname = commandWords[1] + " " + commandWords[2]
    theRelayEntry = lineup.relayentries[event]
    sub_event = theRelayEntry.leg_List[theRelayEntry.letters.index(legStr)].event

    return commandAddOrRemove_relay(lineup, tarlookup, legStr, event, swrname, sub_event, True, eventcount)

  elif "-" in commandWords[0]:
    if commandWords[0][1:].isnumeric():
      print("Removing swimmer from event")
      idxNum = int(commandWords[0][1:])
      event = lineup.evByIdx(idxNum)
      swrname = commandWords[1] + " " + commandWords[2]

      return commandAddOrRemove_indiv(lineup, tarlookup, event, swrname, False, eventcount)

    elif commandWords[0][1].isnumeric():
      print("Removing swimmer from relay event")
      idxNumStr = ""
      letter = 1
      while commandWords[0][letter].isnumeric():
        idxNumStr += commandWords[0][letter]
        letter += 1
      legStr = commandWords[0][letter:]
      idxNum = int(idxNumStr)
      event = lineup.evByIdx(idxNum)
      swrname = commandWords[1] + " " + commandWords[2]
      theRelayEntry = lineup.relayentries[event]
      sub_event = theRelayEntry.leg_List[theRelayEntry.letters.index(legStr)].event

      return commandAddOrRemove_relay(lineup, tarlookup, legStr, event, swrname, sub_event, False, eventcount)

# SWAP!
  elif "S" in commandWords[0]:
    print("Performing Swap")
    returnString = ""
    if commandWords[0][1:].isnumeric():
      #it's indiv
      idxNum_A = int(commandWords[0][1:])
      event_A = lineup.evByIdx(idxNum_A)
      swrname_A = commandWords[1] + " " + commandWords[2]
      returnString += commandAddOrRemove_indiv(lineup, tarlookup, event_A, swrname_A, False, eventcount)
    elif commandWords[0][1].isnumeric():
      #it's relay
      idxNumStr = ""
      letter = 1
      while commandWords[0][letter].isnumeric():
        idxNumStr += commandWords[0][letter]
        letter += 1
      legStr_A = commandWords[0][letter:]
      idxNum_A = int(idxNumStr)
      event_A = lineup.evByIdx(idxNum_A)
      swrname_A = commandWords[1] + " " + commandWords[2]
      theRelayEntry = lineup.relayentries[event_A]
      sub_event_A = theRelayEntry.leg_List[theRelayEntry.letters.index(legStr_A)].event
      returnString += commandAddOrRemove_relay(lineup, tarlookup, legStr_A, event_A, swrname_A, sub_event_A, False, eventcount)

    if commandWords[3][1:].isnumeric():
      #it's indiv
      idxNum_B = int(commandWords[3][1:])
      event_B = lineup.evByIdx(idxNum_B)
      swrname_B = commandWords[4] + " " + commandWords[5]
      returnString += "\n" + commandAddOrRemove_indiv(lineup, tarlookup, event_B, swrname_B, False, eventcount)

      if commandWords[0][1:].isnumeric():
        returnString += "\n" + commandAddOrRemove_indiv(lineup, tarlookup, event_A, swrname_B, True, eventcount)
      elif commandWords[0][1].isnumeric():
        returnString += "\n" + commandAddOrRemove_relay(lineup, tarlookup, legStr_A, event_A, swrname_B, sub_event_A, True, eventcount)

      returnString += "\n" + commandAddOrRemove_indiv(lineup, tarlookup, event_B, swrname_A, True, eventcount)
    elif commandWords[3][1].isnumeric():
      #it's relay
      idxNumStr = ""
      letter = 1
      while commandWords[3][letter].isnumeric():
        idxNumStr += commandWords[3][letter]
        letter += 1
      legStr_B = commandWords[3][letter:]
      idxNum_B = int(idxNumStr)
      event_B = lineup.evByIdx(idxNum_B)
      swrname_B = commandWords[4] + " " + commandWords[5]
      theRelayEntry = lineup.relayentries[event_B]
      sub_event_B = theRelayEntry.leg_List[theRelayEntry.letters.index(legStr_B)].event
      returnString += "\n" + commandAddOrRemove_relay(lineup, tarlookup, legStr_B, event_B, swrname_B, sub_event_B, False, eventcount)

      if commandWords[0][1:].isnumeric():
        returnString += "\n" + commandAddOrRemove_indiv(lineup, tarlookup, event_A, swrname_B, True, eventcount)
      elif commandWords[0][1].isnumeric():
        returnString += "\n" + commandAddOrRemove_relay(lineup, tarlookup, legStr_A, event_A, swrname_B, sub_event_A, True, eventcount)

      returnString += "\n" + commandAddOrRemove_relay(lineup, tarlookup, legStr_B, event_B, swrname_A, sub_event_B, True, eventcount)

    return returnString

def isIndivFull(lineup):
  for entry in lineup.entries:
    if None in lineup.entries[entry]:
      return False
  return True

def isRelayFull(lineup):
  for relayentry in lineup.relayentries:
    if None in lineup.relayentries[relayentry]:
      return False
  return True

def isFull(lineup):
  return isIndivFull(lineup) and isRelayFull(lineup)

def writeLineupCSV(lineup, filepath, filename):
  if not filepath[0] == "/":
    filepath = "/" + filepath
  if not "/MyDrive" in filepath:
    filepath = "/MyDrive" + filepath
  if not "/content/drive" in filepath:
    filepath = "/content/drive" + filepath
  if not filepath[len(filepath) - 1] == "/":
    filepath = filepath + "/"
  try:
    fileOpen = open(filepath + filename + ".csv", "x")
  except:
    fileOpen = open(filepath + filename + ".csv", "w")

  fileOpen.write("Event,Fastest Entry,2nd Fastest Entry,3rd Fastest Entry\n")

  for evIdx in [1,4,5,6,7,8,9,2,10,11,3]:
    ev = lineup.evByIdx(evIdx)
    if evIdx in [1,2,3]:
      if evIdx == 1:
        legNames = ["200 M Relay Bk", "200 M Relay Br", "200 M Relay Fl", "200 M Relay Fr"]
      elif evIdx == 2:
        legNames = ["200 F Relay 1", "200 F Relay 2", "200 F Relay 3", "200 F Relay 4"]
      elif evIdx == 3:
        legNames = ["400 F Relay 1", "400 F Relay 2", "400 F Relay 3", "400 F Relay 4"]
      for leg in range(4):
        fileOpen.write(legNames[leg] + ",")
        for swridx in range(3):
          fileOpen.write(lineup.relayentries[ev].leg_List[leg].entry_List[swridx].swimmer.name)
          if swridx == 2:
            fileOpen.write("\n")
          else:
            fileOpen.write(",")
    else:
      fileOpen.write(str(ev) + ",")
      for swridx in range(3):
        fileOpen.write(lineup.entries[ev].entry_List[swridx].swimmer.name)
        if swridx == 2:
          fileOpen.write("\n")
        else:
          fileOpen.write(",")

  fileOpen.close()

"""# OLAS

This is the Optimal Lineup Algorithm System. What it does is it will auto-fill in the LIS. The algorithm will have to be imperfect because it is really difficult to think how to optimize this lineup.
"""

def autofill_individual(lineup, tarlookup, eventcount, displayPrint, getFirst):
  # Note: parameter displayPrint is used to specify if the function should print what it is doing or not.
  n_rank = 1
  m_selfpowerrank = 1
  while not isIndivFull(lineup) and n_rank <= len(tarlookup.swimmerlist):               # isIndivFull tells us if the lineup has had all
    while not isIndivFull(lineup) and m_selfpowerrank <= len(list(tarlookup.tardict)):  # its individual events filled yet.
      if displayPrint == True:
        print("We are looking for swimmers who rank #" + str(n_rank) + " in the event and it is their #" + str(m_selfpowerrank) + " best event")
      for ev in list(tarlookup.tardict):
        for swr in tarlookup.swimmerlist:
          tar = tarlookup.lookup(swr,ev)
          if tarlookup.getrank(swr,ev) == n_rank and tarlookup.getselfpowerrank(swr,ev) == m_selfpowerrank:
            if displayPrint == True:
              print("|__ Match found: " + str(swr) + " in " + str(ev))
            if canAddIndiv(eventcount, swr) and ((not getFirst) or (lineup.fillUpEvent(ev) <= lineup.fillUpIndiv())):
              if displayPrint == True:
                print("  |__ The match is eligible for another event and so we put him in!")
              commandAddOrRemove_indiv(lineup, tarlookup, ev, swr.name, True, eventcount)   # Note: if event is already full then
            else:                                                                           # this AddOrRemove does nothing
              if displayPrint == True:
                print("  |__ The match is ineligible for more events and so we cannot put him in. Sad!")
      m_selfpowerrank += 1
    n_rank += 1
    m_selfpowerrank = 1
  if isIndivFull(lineup):
    if displayPrint == True:
      print("It worked! The lineup is all done! Yay!")
  else:
    if displayPrint == True:
      print("Sorry, ran out of swimmers before finishing the lineup.")

def autofill_relay(lineup, tarlookup, eventcount, displayPrint):
  n_rank = 1
  m_selfpowerrank = 1
  k_200legiterator = 3
  j_400legiterator = 3
  while not isRelayFull(lineup) and n_rank <= len(tarlookup.swimmerlist):
    while not isRelayFull(lineup) and m_selfpowerrank <= len(list(tarlookup.tardict)):
      if displayPrint == True:
        print("We are looking for swimmers who rank #" + str(n_rank) + " in the event and it is their #" + str(m_selfpowerrank) + " best event")
      for ev in list(tarlookup.tardict):
        if ev == EVENT("50 Free") or ev == EVENT("100 Free") or ev == EVENT("100 Fly") or ev == EVENT("100 Back") or ev == EVENT("100 Breast"):
          for swr in tarlookup.swimmerlist:
            tar = tarlookup.lookup(swr,ev)
            if tarlookup.getrank(swr,ev) == n_rank and tarlookup.getselfpowerrank(swr,ev) == m_selfpowerrank:
              if displayPrint == True:
                print("|__ Match found: " + str(swr) + " in " + str(ev))
              if ev == EVENT("50 Free"):
                if canAddRelay(eventcount, swr):
                  if displayPrint == True:
                    print("  |__ The match is eligible and so we put him in 200 Free Relay in leg " + str(k_200legiterator))
                  successFail = commandAddOrRemove_relay(lineup, tarlookup, k_200legiterator, EVENT("200 Free Relay"), swr.name, ev, True, eventcount)
                  if "Successfully" in successFail:
                    k_200legiterator += -1
                    if k_200legiterator < 0:
                      k_200legiterator = 3
              elif ev == EVENT("100 Back"):
                if canAddRelay(eventcount, swr):
                  if displayPrint == True:
                    print("  |__ The match is eligible and so we put him in 200 Medley Relay in leg backstroke")
                  commandAddOrRemove_relay(lineup, tarlookup, 0, EVENT("200 Medley Relay"), swr.name, ev, True, eventcount)
              elif ev == EVENT("100 Breast"):
                if canAddRelay(eventcount, swr):
                  if displayPrint == True:
                    print("  |__ The match is eligible and so we put him in 200 Medley Relay in leg breaststroke")
                  commandAddOrRemove_relay(lineup, tarlookup, 1, EVENT("200 Medley Relay"), swr.name, ev, True, eventcount)
              elif ev == EVENT("100 Fly"):
                if canAddRelay(eventcount, swr):
                  if displayPrint == True:
                    print("  |__ The match is eligible and so we put him in 200 Medley Relay in leg butterfly")
                  commandAddOrRemove_relay(lineup, tarlookup, 2, EVENT("200 Medley Relay"), swr.name, ev, True, eventcount)
              elif ev == EVENT("100 Free"):
                if canAddRelay(eventcount, swr):
                  if displayPrint == True:
                    print("  |__ The match is eligible and so we put him in 400 Free Relay in leg " + str(j_400legiterator))
                  successFail = commandAddOrRemove_relay(lineup, tarlookup, j_400legiterator, EVENT("400 Free Relay"), swr.name, ev, True, eventcount)
                  if "Successfully" in successFail:
                    j_400legiterator += -1
                    if j_400legiterator < 0:
                      j_400legiterator = 3
                if canAddRelay(eventcount, swr):
                  if displayPrint == True:
                    print("  |__ The match is eligible and so we put him in 200 Medley Relay in leg freestyle")
                  commandAddOrRemove_relay(lineup, tarlookup, 3, EVENT("200 Medley Relay"), swr.name, ev, True, eventcount)
              # if canAddRelay(eventcount, swr):
              #   if displayPrint == True:
              #     print("  |__ The match is eligible for another event and so we put him in!")
              #   successFail = commandAddOrRemove_relay(lineup, tarlookup, leg, ev, swr.name, sub_event, True, eventcount)
              # else:
              #   if displayPrint == True:
              #     print("  |__ The match is ineligible for more events and so we cannot put him in. Sad!")
      m_selfpowerrank += 1
    n_rank += 1
    m_selfpowerrank = 1

  if isRelayFull(lineup):
    if displayPrint == True:
      print("It worked! The lineup is all done! Yay!")
  else:
    if displayPrint == True:
      print("Sorry, ran out of swimmers before finishing the lineup.")

"""# Menu and Navigation

Hello! If you are trying to use my program, this is the part that you will interact with!
"""

#STSS
print("First, we must get the swim times.")
mytl = stss_get_tarlookup()
print(mytl)

#OLAS prelim
mytl.rankeverything()
mytl.find_selfpowers({"50 Free": "0:23.79",
                      "100 Free": "0:52.99",
                      "200 Free": "1:56.49",
                      "500 Free": "5:19.99",
                      "100 Back": "1:02.19",
                      "100 Breast": "1:08.29",
                      "100 Fly": "0:59.49",
                      "200 IM": "2:14.99"})
mytl.selfpowerrankeverything()

lineupName = input("What do you want to name your lineup? (e.g. RMT vs MTB boys)\n")

#LIS init
specialmessage = "The program has begun"        # Initializes special message with a welcome message
myLineup = ConstructNewMCPSLineup(lineupName)   # Uses a function I wrote to make default lineup
myEventCount = ConstructNewEventCount(mytl)
# Uses a function I wrote to make a 2D array connecting swimmer names to how many events they are swimming
# (2D array implementation not shown)

#LIS loop
while True:               # Will repeat until a break
  clearScreen()           # Calls a function to get rid of printed text and clean up the screen
  print(specialmessage)   # Prints string representing results from the previous command executed
  mycommand = PromptNextLineupCommand(myLineup, myEventCount)
  # Calls a function to do the following:
  #  - print out the lineup
  #  - Get the user's next command.
  if mycommand == "":
    break
    # Exits if nothing is entered
  specialmessage = ExecCommand(myLineup, mytl, mycommand, myEventCount)
  # Executes the command that the user gave, meanwhile storing
  # a representation of the results in a string